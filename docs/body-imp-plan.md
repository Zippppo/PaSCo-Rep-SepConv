PaSCo Body Scene Completion - Implementation Plan                                                                                                                                                                                                  

 Overview

 Migrate PaSCo from autonomous driving to human body scene completion.

 Principle: Minimal changes, reuse existing architecture, validate end-to-end first.

 ---
 Architecture Mapping
 ┌─────────────┬──────────────────────────┬─────────────────────┐
 │  Component  │     KITTI (Original)     │    Body (Target)    │
 ├─────────────┼──────────────────────────┼─────────────────────┤
 │ n_classes   │ 20                       │ 72                  │
 ├─────────────┼──────────────────────────┼─────────────────────┤
 │ scene_size  │ [256, 256, 32]           │ [128, 128, 256]     │
 ├─────────────┼──────────────────────────┼─────────────────────┤
 │ in_channels │ 283 (27 + 256 embedding) │ 38 (6 + 32 pos_enc) │
 ├─────────────┼──────────────────────────┼─────────────────────┤
 │ n_infers    │ 1-3                      │ 1 (MVP)             │
 ├─────────────┼──────────────────────────┼─────────────────────┤
 │ voxel_size  │ 0.2m                     │ 4mm                 │
 ├─────────────┼──────────────────────────┼─────────────────────┤
 │ thing_ids   │ [1-8]                    │ [] (semantic only)  │
 └─────────────┴──────────────────────────┴─────────────────────┘
 ---
 Files to Create

 1. pasco/data/body/params.py

 - 72 class names from dataset_info.json
 - class_frequencies (compute from dataset)
 - thing_ids = [] (no instance segmentation)

 2. pasco/data/body/body_dataset.py

 class BodyDataset(Dataset):
     def __init__(self, split, root, target_size=[128,128,256],
                  n_subnets=1, data_aug=False, complete_scale=8):
         ...

     def __getitem__(self, idx) -> dict:
         # Returns same structure as KittiDataset
         return {
             "in_feat": [N, 38],      # xyz + xyz_rel + pos_enc
             "in_coord": [N, 3],      # voxel coordinates
             "semantic_label": [D,H,W],
             "geo_labels": {"1_1":..., "1_2":..., "1_4":...},
             "sem_labels": {"1_1":..., "1_2":..., "1_4":...},
             "mask_label": {"labels":..., "masks":...},
             "min_C": [3], "max_C": [3], "T": [4,4],
         }

 Key methods:
 - _normalize_grid_size(): Pad/crop to [128, 128, 256], fill with class 0
 - _voxelize_sensor_pc(): Point cloud to sparse voxel coords + features
 - _compute_input_features(): xyz(3) + xyz_rel(3) + sinusoidal_pos_enc(32)
 - _generate_multiscale_labels(): Downsample at 1x, 2x, 4x scales

 3. pasco/data/body/collate.py

 def collate_fn_body(batch, complete_scale=8) -> dict:
     # Same structure as semantic_kitti/collate.py
     # Fixed global bounds: [0,0,0] to [127,127,255]

 4. pasco/data/body/body_dm.py

 class BodyDataModule(pl.LightningDataModule):
     # Load split from dataset_split.json (generated by scripts/body/split_dataset.py)
     # Split: 8:1:1 (train:val:test), seed=42
     # Data path: Dataset/voxel_data/BDMAP_*.npz

 5. pasco/data/body/positional_encoding.py

 def sinusoidal_positional_encoding(coords, num_freqs=5):
     # coords: [N, 3] normalized to [0,1]
     # returns: [N, 32] (30D encoding + 2D padding)

 6. configs/body.yaml

 dataset: body
 n_classes: 72
 scene_size: [128, 128, 256]
 in_channels: 38
 n_infers: 1
 num_queries: 72
 voxel_size: 4

 ---
 Files to Modify

 1. pasco/models/net_panoptic_sparse.py

 Line 84: Make scene_size configurable
 # Before:
 self.scene_size = (256 // scale, 256 // scale, 32 // scale)

 # After:
 self.scene_size = scene_size if scene_size else (256 // scale, 256 // scale, 32 // scale)

 Line 180: Make thing_ids configurable
 # Before:
 self.thing_ids = thing_ids  # imported from semantic_kitti

 # After:
 self.thing_ids = thing_ids if thing_ids is not None else []

 2. scripts/train.py

 Add dataset selection:
 @click.option('--dataset', default="kitti", type=click.Choice(['kitti', 'body']))

 # Conditional imports and initialization
 if dataset == "body":
     from pasco.data.body.body_dm import BodyDataModule
     from pasco.data.body.params import class_names, class_frequencies, thing_ids
     n_classes = 72
     in_channels = 38
     scene_size = (128, 128, 256)

 ---
 Implementation Phases

 Phase 1: Data Pipeline

 1. Create pasco/data/body/__init__.py
 2. Create params.py with 72 class definitions
 3. Create positional_encoding.py
 4. Create body_dataset.py:
   - Load .npz files
   - Normalize grid size
   - Voxelize point cloud
   - Generate multi-scale labels
 5. Create collate.py
 6. Create body_dm.py

 Verification: Load dataset, print shapes, visualize one sample

 Phase 2: Model Adaptation

 1. Modify net_panoptic_sparse.py:
   - Add scene_size parameter
   - Add thing_ids parameter
 2. Create configs/body.yaml

 Verification: Forward pass with dummy data

 Phase 3: Training Integration

 1. Modify train.py for dataset selection
 2. Compute class frequencies from dataset
 3. Run training for 1 epoch

 Verification: Loss decreases, no OOM

 ---
 Input Feature Design (38D)

 [0:3]   xyz         - Absolute position (mm)
 [3:6]   xyz_rel     - Position relative to voxel center
 [6:38]  pos_enc     - Sinusoidal encoding (5 freqs x 3 dims x 2 = 30, pad to 32)

 Voxelization:
 voxel_coords = ((sensor_pc - grid_world_min) / 4.0).astype(int)
 unique_coords, inverse = np.unique(voxel_coords, axis=0, return_inverse=True)
 aggregated_xyz = scatter_mean(sensor_pc, inverse)  # Mean position per voxel

 ---
 Critical Implementation Details

 Grid Normalization

 def normalize_grid_size(labels, target=[128,128,256]):
     D, H, W = labels.shape
     TD, TH, TW = target
     result = np.zeros((TD, TH, TW), dtype=labels.dtype)  # class 0 = outside_body

     # Center alignment
     d_off = (TD - D) // 2
     h_off = (TH - H) // 2
     w_off = (TW - W) // 2

     # Copy with bounds checking
     src_d = slice(max(0,-d_off), min(D, TD-d_off))
     tgt_d = slice(max(0,d_off), min(TD, D+d_off))
     # ... same for H, W

     result[tgt_d, tgt_h, tgt_w] = labels[src_d, src_h, src_w]
     return result, [d_off, h_off, w_off]

 Multi-scale Label Generation

 Follow kitti_dataset.py lines 210-266:
 - geo_labels: Binary occupancy (class > 1)
 - sem_labels: Class labels with majority voting

 Mask Label Format

 For semantic-only (no instances):
 mask_label = {
     "labels": [C],           # class indices present
     "masks": [C, D, H, W],   # binary mask per class
 }

 ---
 Verification Checklist

 - BodyDataset loads .npz and returns correct dict structure
 - Grid normalization handles all size variations
 - Voxelization produces valid sparse coordinates
 - Positional encoding has correct shape [N, 32]
 - Collate function returns correct batch format
 - Forward pass completes without error
 - Loss computation produces valid gradients
 - Training loop runs for 1 epoch without OOM

 ---
 Key Reference Files
 ┌─────────────────────┬───────────────────────────────────────────────┐
 │       Purpose       │                     File                      │
 ├─────────────────────┼───────────────────────────────────────────────┤
 │ Dataset template    │ pasco/data/semantic_kitti/kitti_dataset.py    │
 ├─────────────────────┼───────────────────────────────────────────────┤
 │ Collate template    │ pasco/data/semantic_kitti/collate.py          │
 ├─────────────────────┼───────────────────────────────────────────────┤
 │ DataModule template │ pasco/data/semantic_kitti/kitti_dm.py         │
 ├─────────────────────┼───────────────────────────────────────────────┤
 │ Params template     │ pasco/data/semantic_kitti/params.py           │
 ├─────────────────────┼───────────────────────────────────────────────┤
 │ Model entry         │ pasco/models/net_panoptic_sparse.py           │
 ├─────────────────────┼───────────────────────────────────────────────┤
 │ Feature extraction  │ pasco/models/unet3d_sparse_v2.py:CylinderFeat │
 ├─────────────────────┼───────────────────────────────────────────────┤
 │ Training script     │ scripts/train.py                              │
 └─────────────────────┴───────────────────────────────────────────────┘
 ---
 Risk Mitigation
 ┌────────────────────────────────────┬────────────────────────────────────────────┐
 │                Risk                │                 Mitigation                 │
 ├────────────────────────────────────┼────────────────────────────────────────────┤
 │ OOM ([128,128,256] = 4.19M voxels) │ batch_size=1, gradient accumulation        │
 ├────────────────────────────────────┼────────────────────────────────────────────┤
 │ Class imbalance (72 classes)       │ Weighted CE from class_frequencies         │
 ├────────────────────────────────────┼────────────────────────────────────────────┤
 │ Poor convergence                   │ Start with larger lr, add scheduler        │
 ├────────────────────────────────────┼────────────────────────────────────────────┤
 │ Coordinate mismatch                │ Unit test: world → voxel → world roundtrip │
 └────────────────────────────────────┴────────────────────────────────────────────┘